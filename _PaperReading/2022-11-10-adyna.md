---
title: 'Adyna'
date: 2022-11-10
permalink: /project/2022/11/10/Adyna
tags:
  - accelerator
  - simulator
  - gem5
---
[github repo](https://github.com/starkerfirst/adyna)







# Systolic Array Model in Gem5

## Existing Designs

gem5目前大型SimObject的开源代码非常少，唯一能找到的比较完整的是gem5-aladdin中的systolic array model，这个模型也是脉动阵列在github上唯一gem5实现，非常具有学习意义。

[harvard-acc/gem5-aladdin: End-to-end SoC simulation: integrating the gem5 system simulator with the Aladdin accelerator simulator. (github.com)](https://github.com/harvard-acc/gem5-aladdin)

唯一问题也是最大问题是代码的doc几乎没有，复杂而难懂。我大概摸索总结出了一个如下的代码框架(/src/systolic_array)

### system
* **adyna_connection.h**        functions to invoke adyna
* **sys_connection.h**          addition functions to support adyna_connection
* **adyna_params.h**            definitions of params data class
* **adyna.h**                   systematic definition of Adyna (c++ edge) 
* **adyna.py**                  systematic definition of Adyna (Python edge)
* **SConscript**                scons connection file


### microarchitecture
* **dataflow.h**                a complete picture of the whole SA dataflow
* **register.h**                model of double buffer, using timebuf.h
* **pe.h**                      definitions of MAC, PE and IOreg
* **fetch.h**                   definitions of fetch unit
* **scratchpad.h**              definitions of scratchpads and slaveports
* **local_spad_interface**      definitions of masterports to spm 

### data
* **datatype.h**                describe the definition of pixel data (in MAC)
* **tensor.h**                  describe the definition of tensor and its params

### Useless yet
* **Gem5Datapath.h**            systematic definition virtual class (including interface and params)

## My Design

必须承认，虽然gem5在精细和准确方面非常优秀，但是学习曲线非常陡峭。目前以我的水平，最佳的搭建路线是通过event queue这一基本驱动器来构建比较简单的模拟器，之后再逐步引入精细部分（比如Mem System，FIFO request queue，gem5 STL）。



目前一个比较简化的办法，就是将SOC的模拟分为两部分，加速器部分的模拟采用自建事件驱动模拟器，用比较固定的参数来模拟访存和数据移动效率。cpu部分的模拟用stl库，包括HBM等模型，两部分模拟分别进行。当流程跑通之后，再引入高级特性，达到多次迭代的效果。



所以，对于Adyna，我们只要规划好event的出现方式和顺序，把initEvent，exitEvent等eventflow设计完整，就可以较好的模拟出真实结果，逐渐与原来的gem5 API统一。

Adyna architecture
==================
Adyna的spec正在搭建，相关代码已经开始编写，整体架构图如下：

![github repo](http://starkerfirst.github.io/images/adyna_schematic.png)

## Acc

加速器部分采用systolic_array的方式，不过会简化接口加强建模，大概的框架如下图。

![github repo](http://starkerfirst.github.io/images/adyna_acc.png)

## NSR

这应该是Adyna最复杂的部分，因为其承载了很多核心的功能，包括**storage, routing, manipulation and reconfiguration**。相关spec仍在制定。



SPM端口采用gem5 memory system的统一API来实现，这使得之后连接crossbar总线和DRAM模型成为可能。

![github repo](http://starkerfirst.github.io/images/adyna_master_slave1.png)

![github repo](http://starkerfirst.github.io/images/adyna_master_slave2.png)

![github repo](http://starkerfirst.github.io/images/adyna_master_slave3.png)

## NoC

NoC部分采用Garnet Network来建模。

![github repo](http://starkerfirst.github.io/images/adyna_noc.jpg)



